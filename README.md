

Выполнено в рамках обучения

# Условие задачи 
>На языке со статической типизацией (на выбор Java или C#) реализовать скрипт (в виде jar-файла или исполняемой сборки), который реализует обобщенную игру камень-ножницы-бумага (любое число произвольных комбинаций).  
>При запуске параметрами командной строки (аргументы метода main или Main) передаётся нечётное число >=3 неповторяющихся строк (при неправильно заданных аргументах вывести аккуратное сообщение об ошибке — что неверно, пример как правильно). Эти строки — это ходы (например, Камень Ножницы Бумага или Камень Ножницы Бумага Ящерица Спок или 1 2 3 4 5 6 7 8 9).  
>Победа определяется так — половина следующих по кругу выигрывает, половина предыдущих по кругу проигрывает (семантика строк не важна, в какой последовательности что пользователь ввел, в том и играет).  
>Скрипт генерирует случайный ключ (SecureRandom или RandomNumberGenerator — обязательно!) длиной 128 бит, делает свой ход (опять же безопасным рандомом), вычисляет HMAC (на базе SHA2 или SHA3) от хода со сгенерированным ключом, показывает пользователя HMAC. После этого пользователь получает "меню" 1 - Камень, 2 - Ножницы, ...., 0 - Exit. Пользователь делает свой выбор (при некорректном вводе опять отображается "меню"). Скрипт показывает кто победил, ход компьютера и исходный ключ.  
>Таким образом, пользователь может проверить, что компьютер играет честно (не поменял свой ход после хода пользователя).  
>При выборе опции "help" в терминале нужно отобразить таблицу, определяющую какой ход выигрывает.  
>Генерация таблицы должна быть вынесена в отдельный класс, определение "правил" кто победил должно быть в отдельном классе, функции генерации ключа и HMAC должны быть в отдельном классе (всего 4 класса). По максимуму следует использовать базовые библиотеки классов и сторонние библиотеки, а не изобретать велосипед.  
>ЧИСЛО ХОДОВ МОЖЕТ БЫТЬ ЛЮБЫМ (нечетным > 1, зависит от переданных параметров), не зашито в коде.  
>Пример:   
>>java -jar game.jar rock paper scissors lizard Spock  
>HMAC: FAAC40C71B4B12BF0EF5556EEB7C06925D5AE405D447E006BB8A06565338D411  
>Available moves:  
>1 - rock  
>2 - paper  
>3 - scissors  
>4 - lizard  
>5 - Spock  
>0 - exit  
>? - help  
>Enter your move: 2  
>Your move: paper  
>Computer move: rock  
>You win!  
>HMAC key: BD9B5544739FCE7359C267E734E380A2  
>
>> И как пояснение: при вычислении HMAC ключ — это тот самый секретный ключ, который вы сгенерировали. А сообщение — это ход (прямо вот строка хода). После хода пользователя у него будет ключ, ход компьютера, пользователь сможет вычислить HMAC и сравнить с HMAC-ом, который был показан до хода пользователя. Это не очень сложно :))  
>> Частая ошибка — попытка изобрести свой "HMAC" как хэш от случайного "ключа". Так не пойдёт. Если вы показываете одинаковые строки до хода и после хода, пользователь после хода не получает новой информации и, соответсвенно, вы ничего ему не доказываете. Нужно сгенерировать ключ (безопасным генератором), сделать ход компа, вычислить HMAC (стандартным алгоритмом) от хода компа (сообщение) и ключа (ключ), показать HMAC, получить ход пользователя, показать ключ. Перечитывать этот абзац до полного вкуривания.  
>> "Правильный" порядок (хотя пользователь может использовать другой порядок и играть в игру, в которой ножницы побеждают камень; или играть в игру ХОД1 ХОД2 ХОД3): КАМЕНЬ БУМАГА НОЖНИЦЫ или КАМЕНЬ СПОК БУМАГА ЯЩЕРИЦА НОЖНИЦЫ.  


# Инициализация
Предусмотрен запуск jar-файла "Task3.jar" с передачей параметров. 

# Особенности реализации:
Использован JDK11 и система автоматической сборки Maven

Для реализации проекта были использованы следующие библиотеки: 
-import java.util.Scanner;
- import javax.crypto.Mac;
- import javax.crypto.spec.SecretKeySpec;
- import java.nio.ByteBuffer;
- import java.security.SecureRandom;
- import java.util.Random;
- import java.util.HashSet.
Для вывода таблицы  на кансоль использована ASCII Tables for Java (https://github.com/freva/ascii-table)

